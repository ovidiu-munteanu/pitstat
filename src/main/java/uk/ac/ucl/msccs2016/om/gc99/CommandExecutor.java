/*
 * University College London
 * MSc Computer Science
 * September 2017
 *
 * PitStat
 *
 * This software is a component of the final project titled:
 *
 * Change Impact Analysis through Mutation Testing
 *
 * Author: Ovidiu Munteanu
 * Supervisor: Jens Krinke
 *
 * This software is submitted as part requirement for the MSc
 * Computer Science degree at UCL.It is substantially the result
 * of my own work except where explicitly indicated in the code.
 *
 * This software may be freely copied and distributed provided
 * the source is explicitly acknowledged.
 */
package uk.ac.ucl.msccs2016.om.gc99;

import java.io.IOException;
import java.util.Arrays;
import java.util.List;

/**
 * Primary Utility Class used to execute an external command.
 * <p>
 * <b>References:</b><br>
 * A. Alexander, 'Java exec - execute system processes with Java ProcessBuilder and Process (part 1)'.
 * [Online]. Available: <a href="https://alvinalexander.com/java/java-exec-processbuilder-process-1" target="_blank">
 * https://alvinalexander.com/java/java-exec-processbuilder-process-1 </a><br>
 * A. Alexander, 'Java exec - execute system processes with Java ProcessBuilder and Process (part 2)'.
 * [Online]. Available: <a href="https://alvinalexander.com/java/java-exec-processbuilder-process-2" target="_blank">
 * https://alvinalexander.com/java/java-exec-processbuilder-process-1 </a><br>
 * A. Alexander, 'Java exec - execute system processes with Java ProcessBuilder and Process (part 3)'.
 * [Online]. Available: <a href="https://alvinalexander.com/java/java-exec-processbuilder-process-3" target="_blank">
 * https://alvinalexander.com/java/java-exec-processbuilder-process-1 </a><br>
 */
class CommandExecutor {
    private List<String> splitCommand;
    private boolean printCommand;
    private ThreadedStreamHandler inputStreamHandler, errorStreamHandler;

    /**
     *
     */
    CommandExecutor() {
        this.splitCommand = null;
    }

    /**
     * Executes the given command and returns the result of execution.
     *
     * @param command string containing the command to be executed
     * @return return error code; 0 (zero) if no error
     */
    int execute(String command) {
        return execute(command, false);
    }

    /**
     * Executes the given system command and return result of execution.
     *
     * @param command      String containing the command to be executed
     * @param printCommand boolean indicating whether the command should be printed out to the standard output
     *                     true if the command should be printed out, false othewise
     * @return return error code; 0 (zero) if no error
     */
    int execute(String command, boolean printCommand) {
        if (command == null) {
            throw new NullPointerException("Command string is null.");
        } else if (command.length() == 0) {
            throw new IllegalArgumentException("Command string is empty.");
        }

        this.splitCommand = splitCommand(command);
        this.printCommand = printCommand;
        return execute();
    }

    /**
     * Get the standard output (stdout) from the command executed.
     */
    List<String> getStandardOutput() {
        return inputStreamHandler.getOutputBuffer();
    }

    /**
     * Get the standard error (stderr) from the command you just exec'd.
     */
    List<String> getStandardError() {
        return errorStreamHandler.getOutputBuffer();
    }

    /**
     * @return
     */
    private int execute() {
        int exitValue;

        if (printCommand)
            System.out.println("$ " + String.join(" ", splitCommand));

        try {

            ProcessBuilder processBuilder = new ProcessBuilder(splitCommand);

            Process process = processBuilder.start();

            inputStreamHandler = new ThreadedStreamHandler(process.getInputStream());
            errorStreamHandler = new ThreadedStreamHandler(process.getErrorStream());

            inputStreamHandler.start();
            errorStreamHandler.start();

            exitValue = process.waitFor();

            inputStreamHandler.interrupt();
            errorStreamHandler.interrupt();
            inputStreamHandler.join();
            errorStreamHandler.join();

        } catch (IOException e) {
            exitValue = 1;
        } catch (InterruptedException e) {
            // generated by process.waitFor() call
            exitValue = 2;
        }

        return exitValue;
    }

    /**
     * Passed as argument to CommandExecutor; splits command string into individual command components
     *
     * @param command String containing the command to be executed
     * @return ArrayList of strings containing the command components
     */
    private static List<String> splitCommand(String command) {
        return Arrays.asList(command.split("\\s+"));
    }
}







