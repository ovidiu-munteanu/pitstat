package uk.ac.ucl.msccs2016.om.gc99;

import java.io.IOException;
import java.io.InputStream;
import java.util.Arrays;
import java.util.List;

class CommandExecutor {
    private List<String> splitCommand;
    private boolean printCommand;
    private CommandStreamThreadedHandler inputStreamHandler;
    private CommandStreamThreadedHandler errorStreamHandler;

    CommandExecutor() {
        this.splitCommand = null;
        this.printCommand = false;
    }

    void setCommand(String command) {
        this.setCommand(splitCommand(command));
    }

    void setCommand(List<String> splitCommand) {
        this.splitCommand = splitCommand;
    }

    void setPrintCommand(boolean printCommand) {
        this.printCommand = printCommand;
    }

    int executeCommand(String command) {
        return executeCommand(command, false);
    }

    int executeCommand(List<String> splitCommand) {
        return executeCommand(splitCommand, false);
    }

    int executeCommand(String command, boolean printCommand) {
        return executeCommand(splitCommand(command), printCommand);
    }

    int executeCommand(List<String> splitCommand, boolean printCommand) {
        this.setCommand(splitCommand);
        this.printCommand = printCommand;
        return executeCommand();
    }

    int executeCommand() {
        if (this.splitCommand == null)
            throw new NullPointerException("Command is not set. (field splitCommand is null)");

        int exitValue;

        if (printCommand)
            System.out.println("$ " + String.join(" ", splitCommand));

        try {
            ProcessBuilder pb = new ProcessBuilder(splitCommand);

            // pb.redirectOutput(ProcessBuilder.Redirect.INHERIT);

            Process process = pb.start();

            InputStream inputStream = process.getInputStream();
            InputStream errorStream = process.getErrorStream();

            inputStreamHandler = new CommandStreamThreadedHandler(inputStream);
            errorStreamHandler = new CommandStreamThreadedHandler(errorStream);

            inputStreamHandler.start();
            errorStreamHandler.start();

            exitValue = process.waitFor();

            inputStreamHandler.interrupt();
            errorStreamHandler.interrupt();
            inputStreamHandler.join();
            errorStreamHandler.join();

        } catch (IOException e) {
            exitValue = 1;

        } catch (InterruptedException e) {
            // generated by process.waitFor() call
            exitValue = 2;

        }

        return exitValue;
    }

    /**
     * Splits command string into strings list of individual command components;
     * passed as argument to CommandExecutor
     *
     * @param command
     * @return
     */
    static List<String> splitCommand(String command) {
        return Arrays.asList(command.split("\\s+"));
    }

    /**
     * Get the standard output (stdout) from the command you just exec'd.
     */
    StringBuilder getStandardOutput() {
        return inputStreamHandler.getOutputBuffer();
    }

    int getStandardOutputLines() {
        return inputStreamHandler.getOutputBufferLines();
    }

    /**
     * Get the standard error (stderr) from the command you just exec'd.
     */
    StringBuilder getStandardError() {
        return errorStreamHandler.getOutputBuffer();
    }

    int getStandardErrorLines() {
        return errorStreamHandler.getOutputBufferLines();
    }

}







